'use strict';

// MODULES //

var debug = require( 'debug' )( 'series' );
var isFunction = require( 'validate.io-function' );
var fname = require( 'utils-function-name' );
var wrap = require( 'utils-try-function' );


// SERIES //

/**
* FUNCTION: series()
*	Creates a series function.
*
* @param {...*} [args] - series arguments
* @returns {Function} series function
*/
function series() {
	var phases;
	var names;
	var done;
	var args;
	var len;
	var idx;
	var i;

	len = arguments.length;
	args = new Array( len );
	for ( i = 0; i < len; i++ ) {
		args[ i ] = arguments[ i ];
	}
	args.push( next );
	phases = [];
	names = [];
	idx = -1;

	/**
	* FUNCTION: exec( clbk )
	*	Executes a series.
	*
	* @param {Function} clbk - callback to invoke after executing a series
	* @returns {Void}
	*/
	function exec( clbk ) {
		if ( !isFunction( clbk ) ) {
			throw new TypeError( 'invalid input argument. Must provide a function. Value: `' + clbk + '`.' );
		}
		done = clbk;
		debug( 'Executing a series.' );
		next();
	} // end FUNCTION exec()

	/**
	* FUNCTION: phase( fcn[, thisArg] )
	*	Registers a series phase.
	*
	* @param {Function} fcn - phase
	* @param {*} [thisArg] - phase context
	* @returns {Function} series function
	*/
	function phase( fcn, thisArg ) {
		var name;
		var ctx;
		if ( !isFunction( fcn ) ) {
			throw new TypeError( 'invalid input argument. Must provide a function. Value: `' + fcn + '`.' );
		}
		if ( arguments.length > 1 ) {
			ctx = thisArg;
		} else {
			ctx = null;
		}
		name = fname( fcn );
		debug( 'Registering a new phase: `%s` (%d)', name, phases.length );

		phases.push( wrap( fcn, thisArg ) );
		names.push( name );

		return exec;
	} // end FUNCTION phase()

	/**
	* FUNCTION: next( [error] )
	*	Runs the next series phase.
	*
	* @private
	* @param {Error} [error] - error object
	* @returns {Void}
	*/
	function next( error ) {
		var err;
		if ( error ) {
			debug( '`%s` (%d) series phase returned an error: %s', names[ idx ], idx, error.message );
			return done( error );
		}
		if ( idx >= 0 ) {
			debug( 'Finished series phase: `%s` (%d)', names[ idx ], idx );
		}
		idx += 1;
		if ( idx === phases.length ) {
			debug( 'Finished executing the series.' );
			return done();
		}
		debug( 'Entering series phase: `%s` (%d)', names[ idx], idx );
		err = phases[ idx ].apply( null, args );
		if ( err instanceof Error ) {
			return next( err );
		}
	} // end FUNCTION next()

	exec.phase = phase;
	return exec;
} // end FUNCTION series()


// EXPORTS //

module.exports = series;
